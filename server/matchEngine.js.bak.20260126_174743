import crypto from "crypto";
import fs from "fs";
import path from "path";
import { addXp } from "./db.js";
import { judgeGuess } from "./genlayerJudge.mjs";

/* ---------------- Helpers ---------------- */

function nowMs() {
  return Date.now();
}

function uid(prefix = "") {
  return prefix + crypto.randomBytes(8).toString("hex");
}

function clamp(n, a, b) {
  return Math.max(a, Math.min(b, n));
}

function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

/* ---------------- Cases (100 images) ---------------- */

// Loads ./cases.json from the server folder
function loadCasesFromDisk() {
  const p = path.join(process.cwd(), "cases.json");
  const raw = fs.readFileSync(p, "utf8");
  const arr = JSON.parse(raw);

  if (!Array.isArray(arr) || arr.length < 5) {
    throw new Error("cases.json must be an array with at least 5 items");
  }
  for (const c of arr) {
    if (!c?.id || !c?.imageUrl || !c?.secretPrompt) {
      throw new Error("Each case must have { id, imageUrl, secretPrompt }");
    }
  }
  return arr;
}

// Phase lengths (tune later)
const PHASE_MS = {
  reveal: 12_000,
  submit: 45_000,
  verdict: 8_000,
  challenge_window: 25_000,
  challenge_vote: 25_000,
};

export class MatchEngine {
  constructor(io) {
    this.io = io;
    this.rooms = new Map(); // roomId -> RoomState
  }

  /* ---------------- Room lifecycle ---------------- */

  ensureRoom(roomId) {
    const rid = (roomId || "").trim() || "genlayer";
    let room = this.rooms.get(rid);
    if (!room) {
      room = {
        roomId: rid,
        host: null,
        members: [], // { wallet, displayName }
        match: null,
        timers: { phaseTimeout: null },
      };
      this.rooms.set(rid, room);
    }
    return room;
  }

  getRoom(roomId) {
    const rid = (roomId || "").trim() || "genlayer";
    return this.rooms.get(rid) || null;
  }

  emitRoomState(room) {
    this.io.to(room.roomId).emit("room:state", this.publicRoomState(room));
  }

  publicRoomState(room) {
    return {
      roomId: room.roomId,
      host: room.host,
      members: room.members,
      match: room.match,
    };
  }

  /* ---------------- Member management ---------------- */

  joinRoom({ socket, roomId, wallet, displayName }) {
    const room = this.ensureRoom(roomId);
    const w = (wallet || "").toLowerCase();

    if (!w.startsWith("0x") || w.length < 10) throw new Error("Invalid wallet");

    socket.join(room.roomId);

    const existing = room.members.find((m) => m.wallet.toLowerCase() === w);
    if (!existing) {
      room.members.push({
        wallet,
        displayName: (displayName || "").trim() || `player_${wallet.slice(2, 6)}`,
      });
    } else if (displayName && displayName.trim() && displayName !== existing.displayName) {
      existing.displayName = displayName.trim();
    }

    if (!room.host) room.host = wallet;

    this.emitRoomState(room);
    return room;
  }

  leaveRoom({ socket, roomId, wallet }) {
    const room = this.getRoom(roomId);
    if (!room) return;

    const w = (wallet || "").toLowerCase();
    socket.leave(room.roomId);

    room.members = room.members.filter((m) => m.wallet.toLowerCase() !== w);

    if (room.host && room.host.toLowerCase() === w) {
      room.host = room.members[0]?.wallet || null;
    }

    if (room.members.length === 0) {
      this.stopMatch(room);
      this.rooms.delete(room.roomId);
      return;
    }

    this.emitRoomState(room);
  }

  /* ---------------- Match state machine ---------------- */

  startMatch({ roomId, wallet, rounds = 3 }) {
    const room = this.getRoom(roomId);
    if (!room) throw new Error("Room not found");

    const isHost = room.host && room.host.toLowerCase() === (wallet || "").toLowerCase();
    if (!isHost) throw new Error("Only host can start match");

    if (room.match && room.match.phase !== "completed") {
      throw new Error("Match already running");
    }

    const CASES = loadCasesFromDisk();
    const chosen = this.pickCases(CASES, rounds);

    room.match = {
      matchId: uid("match_"),
      phase: "reveal",
      isJudging: false,
      startedAtMs: nowMs(),
      currentRoundIndex: 0,
      rounds: chosen.map((c) => ({
        roundId: uid("round_"),
        caseId: c.id,
        imageUrl: c.imageUrl,
        secretPrompt: c.secretPrompt, // server-side MVP
        submissions: {}, // walletLower -> { text, submittedAtMs }
        scores: {}, // walletLower -> { score, reasoning }
      })),
      leaderboard: {}, // roundId -> [{ wallet, score, reasoning }]
      challenge: null,
      finalLeaderboard: [], // [{ wallet, displayName, totalXp }]
      phaseEndsAtMs: nowMs() + PHASE_MS.reveal,
    };

    this.emitRoomState(room);
    this.scheduleNextPhase(room);
  }

  stopMatch(room) {
    this.clearTimers(room);
    if (room.match) {
      room.match.phase = "completed";
      room.match.phaseEndsAtMs = null;
    }
  }

  clearTimers(room) {
    if (room.timers?.phaseTimeout) {
      clearTimeout(room.timers.phaseTimeout);
      room.timers.phaseTimeout = null;
    }
  }

  scheduleNextPhase(room) {
    this.clearTimers(room);
    const match = room.match;
    if (!match?.phaseEndsAtMs) return;

    const delay = Math.max(0, match.phaseEndsAtMs - nowMs());
    room.timers.phaseTimeout = setTimeout(() => {
      try {
        this.advancePhase(room.roomId);
      } catch (e) {
        console.error("advancePhase error:", e);
        this.finishMatch(room);
        this.emitRoomState(room);
      }
    }, delay);
  }

  advancePhase(roomId) {
    const room = this.getRoom(roomId);
    if (!room?.match) return;

    const match = room.match;
    const phase = match.phase;
    const round = match.rounds[match.currentRoundIndex];

    if (!round) return this.finishMatch(room);

    if (phase === "challenge_vote") {
      this.resolveChallenge(room);
    }

    if (phase === "reveal") {
      match.phase = "submit";
      match.phaseEndsAtMs = nowMs() + PHASE_MS.submit;
      this.emitRoomState(room);
      return this.scheduleNextPhase(room);
    }

    if (phase === "submit") {
  // Enter verdict, but don't start the verdict timer yet
  match.phase = "verdict";
  match.isJudging = true;
  match.phaseEndsAtMs = null;

  // Let UI switch to verdict immediately ("Judging...")
  this.emitRoomState(room);

  this.scoreRound(room, round)
    .then(() => {
      match.isJudging = false;

      // Start verdict countdown ONLY after scoring is ready
      match.phaseEndsAtMs = nowMs() + PHASE_MS.verdict;

      this.emitRoomState(room);
      this.scheduleNextPhase(room);
    })
    .catch((e) => {
      console.error("scoreRound failed:", e);

      match.isJudging = false;
      match.phaseEndsAtMs = nowMs() + PHASE_MS.verdict;

      this.emitRoomState(room);
      this.scheduleNextPhase(room);
    });

  return;
}

    if (phase === "verdict") {
      match.phase = "challenge_window";
      match.phaseEndsAtMs = nowMs() + PHASE_MS.challenge_window;
      match.challenge = null;
      this.emitRoomState(room);
      return this.scheduleNextPhase(room);
    }

    if (phase === "challenge_window") {
      if (!match.challenge) return this.nextRoundOrFinish(room);
      match.phase = "challenge_vote";
      match.phaseEndsAtMs = nowMs() + PHASE_MS.challenge_vote;
      if (!match.challenge.endsAtMs) match.challenge.endsAtMs = match.phaseEndsAtMs;
      this.emitRoomState(room);
      return this.scheduleNextPhase(room);
    }

    if (phase === "challenge_vote") {
      return this.nextRoundOrFinish(room);
    }
  }

  nextRoundOrFinish(room) {
    const match = room.match;
    if (!match) return;

    const nextIndex = match.currentRoundIndex + 1;
    if (nextIndex >= match.rounds.length) {
      return this.finishMatch(room);
    }

    match.currentRoundIndex = nextIndex;
    match.phase = "reveal";
    match.phaseEndsAtMs = nowMs() + PHASE_MS.reveal;
    match.challenge = null;

    this.emitRoomState(room);
    this.scheduleNextPhase(room);
  }

  finishMatch(room) {
    this.clearTimers(room);
    if (!room.match) return;

    room.match.phase = "completed";
    room.match.phaseEndsAtMs = null;

    // Build per-match final leaderboard and persist global XP
    this.buildFinalLeaderboardAndPersist(room);

    this.emitRoomState(room);
  }

  /* ---------------- Final leaderboard + persistence ---------------- */

  buildFinalLeaderboardAndPersist(room) {
    const match = room.match;
    if (!match) return;

    // totalXp = sum of per-round scores
    const totals = new Map(); // walletLower -> totalXp

    for (const r of match.rounds || []) {
      for (const [walletLower, s] of Object.entries(r.scores || {})) {
        totals.set(walletLower, (totals.get(walletLower) || 0) + (Number(s.score) || 0));
      }
    }

    const finalLeaderboard = [];
    for (const [walletLower, totalXp] of totals.entries()) {
      const member = room.members.find((m) => m.wallet.toLowerCase() === walletLower);
      const displayName = member?.displayName || `player_${walletLower.slice(2, 6)}`;
      const wallet = member?.wallet || walletLower;

      finalLeaderboard.push({ wallet, displayName, totalXp });

      // persist globally
      try {
        addXp({ wallet, deltaXp: totalXp, displayName });
      } catch (e) {
        console.error("addXp failed:", e);
      }
    }

    finalLeaderboard.sort((a, b) => b.totalXp - a.totalXp);
    match.finalLeaderboard = finalLeaderboard;
  }

  /* ---------------- Submissions ---------------- */

  submit({ roomId, wallet, roundId, text }) {
    const room = this.getRoom(roomId);
    if (!room?.match) return;

    const match = room.match;
    if (match.phase !== "submit") return;

    const round = match.rounds.find((r) => r.roundId === roundId);
    if (!round) return;

    const w = (wallet || "").toLowerCase();
    const t = (text || "").trim();
    if (!t) return;

    round.submissions[w] = { text: t.slice(0, 240), submittedAtMs: nowMs() };
    this.emitRoomState(room);
  }

  /* ---------------- Challenge / voting ---------------- */

  createChallenge({ roomId, wallet, roundId, reasonCode = "too_harsh" }) {
    const room = this.getRoom(roomId);
    if (!room?.match) return;

    const match = room.match;
    if (match.phase !== "challenge_window") return;
    if (match.challenge) return;

    match.challenge = {
      roundId,
      createdBy: wallet,
      reasonCode,
      votes: {},
      endsAtMs: nowMs() + PHASE_MS.challenge_vote,
    };

    match.phase = "challenge_vote";
    match.phaseEndsAtMs = match.challenge.endsAtMs;

    this.emitRoomState(room);
    this.scheduleNextPhase(room);
  }

  voteChallenge({ roomId, wallet, voteYes }) {
    const room = this.getRoom(roomId);
    if (!room?.match) return;

    const match = room.match;
    if (match.phase !== "challenge_vote") return;

    const ch = match.challenge;
    if (!ch) return;

    const w = (wallet || "").toLowerCase();
    ch.votes[w] = !!voteYes;

    this.emitRoomState(room);
  }

  resolveChallenge(room) {
    const match = room.match;
    if (!match?.challenge) return;

    const ch = match.challenge;
    const round = match.rounds.find((r) => r.roundId === ch.roundId);
    if (!round) return;

    const votes = Object.values(ch.votes || {});
    const yes = votes.filter(Boolean).length;
    const no = votes.length - yes;

    const overturn = yes > no && votes.length > 0;

    if (overturn) {
      for (const w of Object.keys(round.scores)) {
        round.scores[w].score = clamp(round.scores[w].score + 8, 0, 100);
        round.scores[w].reasoning = "Democracy override: crowd agreed the judge was too harsh.";
      }
      this.buildLeaderboard(match, round);
    }

    match.challenge = {
      ...ch,
      resolved: true,
      result: overturn ? "overturned" : "upheld",
      yes,
      no,
    };
  }

  /* ---------------- Scoring ---------------- */

async scoreRound(room, round) {
  const entries = Object.entries(round.submissions || {});
  const scores = {};

  for (const [walletLower, sub] of entries) {
    const guess = sub.text || "";
    const secret = round.secretPrompt || "";

    let score = 0;
    let reasoning = "";

    try {
      //  GenLayer Studio Judge (CLI-based, safe)
      const res = await judgeGuess({ guess, secret });
      score = Number(res.score) || 0;
      reasoning = res.reasoning || "";
    } catch (e) {
      //  Fallback (never breaks gameplay)
      score = this.simpleSemanticScore(guess, secret);
      reasoning = this.oneSentenceReasoning(score);
      console.warn("GenLayer judge failed, fallback used:", e.message);
    }

    scores[walletLower] = { score, reasoning };
  }

  round.scores = scores;
  this.buildLeaderboard(room.match, round);
}

  buildLeaderboard(match, round) {
    const list = Object.entries(round.scores || {}).map(([walletLower, s]) => ({
      wallet: walletLower,
      score: s.score,
      reasoning: s.reasoning,
    }));

    list.sort((a, b) => b.score - a.score);
    match.leaderboard = match.leaderboard || {};
    match.leaderboard[round.roundId] = list;
  }

  simpleSemanticScore(guess, secret) {
    const g = (guess || "").toLowerCase();
    const s = (secret || "").toLowerCase();

    const gt = new Set(g.split(/[^a-z0-9]+/).filter(Boolean));
    const st = new Set(s.split(/[^a-z0-9]+/).filter(Boolean));

    let inter = 0;
    for (const t of gt) if (st.has(t)) inter++;

    const union = new Set([...gt, ...st]).size || 1;
    const jaccard = inter / union;

    const lenBonus = clamp(g.length / 180, 0, 1) * 0.12;
    const raw = (jaccard * 0.88 + lenBonus) * 100;

    return Math.round(clamp(raw, 0, 100));
  }

  oneSentenceReasoning(score) {
    if (score >= 85) return "Strong match on subject and style—your prompt captures the intent closely.";
    if (score >= 70) return "Good alignment overall, but a few key details or stylistic cues are missing.";
    if (score >= 55) return "Some correct elements, though the core style/scene differs from the target prompt.";
    if (score >= 35) return "Partial overlap, but the prompt’s main subject and tone don’t match well.";
    return "Low similarity—your guess misses the prompt’s core subject, setting, and style.";
  }

  pickCases(CASES, n) {
    const count = clamp(Number(n || 3), 1, 10);
    const shuffled = shuffle(CASES);
    const selected = shuffled.slice(0, count);
    // wrap if not enough
    while (selected.length < count) selected.push(...shuffled);
    return selected.slice(0, count);
  }
}
