import 'dotenv/config';
import express from 'express';
import cors from 'cors';
import http from 'http';
import { Server } from 'socket.io';
import { z } from 'zod';
import { recoverMessageAddress } from 'viem';

import { topPlayers } from './db.js';
import { upsertPlayer, getGlobalLeaderboard } from './leaderboardStore.js';
import { MatchEngine } from './matchEngine.js';
const app = express();
app.use(cors());
app.use(express.json());

/* PATCH: GLOBAL_LEADERBOARD_FROM_DB */
app.get('/api/leaderboard/global', (req, res) => {
  try {
    const rows = topPlayers(25);
    return res.json({
      ok: true,
      players: rows.map((p) => ({
        wallet: p.wallet,
        displayName: p.displayName,
        xp: p.totalXp,                 // DB column -> API field
        updatedAt: (p.updatedAt || 0) * 1000, // DB stores seconds, UI expects ms
      })),
    });
  } catch (e) {
    return res.status(500).json({ ok: false, error: String(e) });
  }
});



app.get('/api/leaderboard/global', (req, res) => {
  const limit = Math.min(100, Math.max(1, Number(req.query.limit || 25)));
  const players = getGlobalLeaderboard(limit);
  
    res.json({ ok: true, players });
});

const server = http.createServer(app);
const io = new Server(server, { cors: { origin: '*' } });

const engine = new MatchEngine(io);

const PORT = Number(process.env.PORT || 3001);

// --------------------
// In-memory MVP storage
// --------------------
/**
 * For MVP we keep state in memory.
 * For production, move to Postgres/Redis.
 */
const users = new Map(); // wallet -> { displayName, updatedAt }
const rooms = new Map(); // roomId -> { host, members: Map(wallet->{displayName}), state }
const matches = new Map(); // roomId -> { rounds, currentRoundIndex, phase, phaseEndsAt, submissions, leaderboard, challenge }

const NameSchema = z.object({
  wallet: z.string().regex(/^0x[a-fA-F0-9]{40}$/),
  displayName: z.string().min(1).max(20).regex(/^[a-zA-Z0-9_]+$/),
  timestamp: z.number().int().positive(),
  signature: z.string().min(10)
});

app.get('/health', (_req, res) => res.json({ ok: true }));

/**
 * POST /api/profile/display-name
 * Body: { wallet, displayName, timestamp, signature }
 *
 * The client signs:
 *   "Set display name to <displayName> at <timestamp>"
 */
app.post('/api/profile/display-name', async (req, res) => {
  const parsed = NameSchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json({ ok: false, error: parsed.error.flatten() });

  const { wallet, displayName, timestamp, signature } = parsed.data;
  const message = `Set display name to ${displayName} at ${timestamp}`;

  try {
    const recovered = await recoverMessageAddress({ message, signature });
    if (recovered.toLowerCase() !== wallet.toLowerCase()) {
      return res.status(401).json({ ok: false, error: 'Signature does not match wallet' });
    }

    users.set(wallet.toLowerCase(), { displayName, updatedAt: Date.now() });
    // Persist name to global leaderboard DB
    try {
      upsertPlayer({ wallet, displayName });
    } catch (e) {
      console.error("upsertPlayer failed:", e);
    }

    return res.json({ ok: true });
} catch (e) {
    return res.status(500).json({ ok: false, error: String(e) });
  }
});

// --------------------
// Socket.IO (Rooms + Match State)
// --------------------
function getOrCreateRoom(roomId, hostWallet) {
  if (!rooms.has(roomId)) {
    rooms.set(roomId, {
      host: hostWallet,
      members: new Map(),
      createdAt: Date.now()
    });
  }
  return rooms.get(roomId);
}

function nowMs() { return Date.now(); }

function emitRoomState(roomId) {
  const room = rooms.get(roomId);
  const match = matches.get(roomId);
  const members = [...(room?.members ?? new Map()).entries()].map(([wallet, m]) => ({ wallet, displayName: m.displayName }));
  io.to(roomId).emit('room:state', {
    roomId,
    host: room?.host ?? null,
    members,
    match: match ?? null
  });
}

function startMatch(roomId) {
  // MVP content: hardcoded 3 rounds (replace with weekly pack file on disk)
  const rounds = [
    {
      roundId: 'r1',
      imageUrl: 'https://picsum.photos/seed/genlayer1/800/500',
      schemaHint: { theme: 'Cyberpunk Animals' }
    },
    {
      roundId: 'r2',
      imageUrl: 'https://picsum.photos/seed/genlayer2/800/500',
      schemaHint: { theme: 'Cyberpunk Animals' }
    },
    {
      roundId: 'r3',
      imageUrl: 'https://picsum.photos/seed/genlayer3/800/500',
      schemaHint: { theme: 'Cyberpunk Animals' }
    }
  ];

  const match = {
    rounds,
    currentRoundIndex: 0,
    phase: 'reveal', // reveal -> submit -> verdict -> challenge(optional) -> next
    phaseEndsAt: nowMs() + 30_000,
    submissions: {}, // roundId -> { wallet -> text }
    leaderboard: {}, // roundId -> array of {wallet, score, reasoning}
    challenge: null  // { roundId, createdAt, endsAt, votes: {wallet: boolean}, reasonCode }
  };

  matches.set(roomId, match);
  schedulePhaseTick(roomId);
  emitRoomState(roomId);
}

/* OLD_SCHEDULER_DISABLED
function schedulePhaseTick(roomId) {
  const tick = () => {
    const match = matches.get(roomId);
    if (!match) return;

    const { phase, phaseEndsAt } = match;
    if (nowMs() < phaseEndsAt) {
      setTimeout(tick, 250);
      return;
    }

    // Phase transitions
    const currentRound = match.rounds[match.currentRoundIndex];
    if (!currentRound) {
      match.phase = 'completed';
      emitRoomState(roomId);
      return;
    }

    if (phase === 'reveal') {
      match.phase = 'submit';
      match.phaseEndsAt = nowMs() + 75_000;
      emitRoomState(roomId);
      setTimeout(tick, 250);
      return;
    }

    if (phase === 'submit') {
      match.phase = 'verdict';
      match.phaseEndsAt = nowMs() + 20_000; // UI breathing room while we "score"
      // TODO: call GenLayer IC score_round here
      // For MVP scaffolding, we create a mock leaderboard.
      const roundId = currentRound.roundId;
      const subs = match.submissions[roundId] || {};
      const scored = Object.entries(subs).map(([wallet, text]) => ({
        wallet,
        score: Math.min(100, 40 + text.length % 61),
        reasoning: 'Mock judge: scored by length; replace with IC reasoning.'
      })).sort((a, b) => b.score - a.score);
      match.leaderboard[roundId] = scored;

      emitRoomState(roomId);
      setTimeout(tick, 250);
      return;
    }

    if (phase === 'verdict') {
      // Open a short window where someone may initiate a challenge.
      match.phase = 'challenge_window';
      match.phaseEndsAt = nowMs() + 20_000;
      emitRoomState(roomId);
      setTimeout(tick, 250);
      return;
    }

    if (phase === 'challenge_window') {
      // If no challenge triggered, advance to next round reveal
      if (!match.challenge) {
        match.currentRoundIndex += 1;
        match.phase = 'reveal';
        match.phaseEndsAt = nowMs() + 30_000;
        emitRoomState(roomId);
        setTimeout(tick, 250);
        return;
      } else {
        // challenge already created, go to full voting
        match.phase = 'challenge_vote';
        match.phaseEndsAt = match.challenge.endsAt;
        emitRoomState(roomId);
        setTimeout(tick, 250);
        return;
      }
    }

    if (phase === 'challenge_vote') {
      // TODO: call GenLayer IC resolve_challenge here based on votes
      // MVP: if YES votes > NO votes, add +3 to everyone (example)
      const ch = match.challenge;
      const votes = ch?.votes || {};
      let yes = 0, no = 0;
      for (const v of Object.values(votes)) (v ? yes++ : no++);
      const passed = yes > no;

      const roundId = ch.roundId;
      if (passed) {
        const lb = match.leaderboard[roundId] || [];
        match.leaderboard[roundId] = lb.map(x => ({ ...x, score: Math.min(100, x.score + 3), reasoning: x.reasoning + ' (+3 via mock democracy)' }))
          .sort((a, b) => b.score - a.score);
      }

      match.challenge = null;
      match.currentRoundIndex += 1;
      match.phase = 'reveal';
      match.phaseEndsAt = nowMs() + 30_000;
      emitRoomState(roomId);
      setTimeout(tick, 250);
      return;
    }

    // fallback
    setTimeout(tick, 250);
  };

  setTimeout(tick, 250);
}


END_OLD_SCHEDULER_DISABLED */

io.on('connection', (socket) => {

  socket.on('room:join', (payload) => {
    try {
      const { roomId, wallet } = payload || {};
      const w = (wallet || '').toLowerCase();
      const u = users.get(w);
      const displayName = u?.displayName;
      engine.joinRoom({ socket, roomId, wallet, displayName });
    } catch (e) {
      socket.emit('error', { message: e?.message || String(e) });
    }
  });
socket.on('room:leave', (payload) => {
    try {
      const { roomId, wallet } = payload || {};
      engine.leaveRoom({ socket, roomId, wallet });
    } catch (e) {
      socket.emit('error', { message: e?.message || String(e) });
    }
  });

  socket.on('match:start', (payload) => {
    try {
      const { roomId, wallet } = payload || {};
      engine.startMatch({ roomId, wallet, rounds: 3 });
    } catch (e) {
      socket.emit('error', { message: e?.message || String(e) });
    }
  });

  socket.on('round:submit', (payload) => {
    try {
      engine.submit(payload || {});
    } catch (e) {
      socket.emit('error', { message: e?.message || String(e) });
    }
  });

  socket.on('challenge:create', (payload) => {
    try {
      engine.createChallenge(payload || {});
    } catch (e) {
      socket.emit('error', { message: e?.message || String(e) });
    }
  });

  socket.on('challenge:vote', (payload) => {
    try {
      engine.voteChallenge(payload || {});
    } catch (e) {
      socket.emit('error', { message: e?.message || String(e) });
    }
  });
});

server.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});
